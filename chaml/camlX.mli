(*****************************************************************************)
(*  ChaML, a type-checker that uses constraints and a kernel language        *)
(*  Copyright (C) 2010 Jonathan Protzenko                                    *)
(*                                                                           *)
(*  This program is free software: you can redistribute it and/or modify     *)
(*  it under the terms of the GNU General Public License as published by     *)
(*  the Free Software Foundation, either version 3 of the License, or        *)
(*  (at your option) any later version.                                      *)
(*                                                                           *)
(*  This program is distributed in the hope that it will be useful,          *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of           *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *)
(*  GNU General Public License for more details.                             *)
(*                                                                           *)
(*  You should have received a copy of the GNU General Public License        *)
(*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    *)
(*                                                                           *)
(*****************************************************************************)

(** An explicitely typed AST (eXplicit Caml). Contains two types of trees: those
 * generated by the constraint generator and those generated by the translator
 * that removes the solver structures and replaces them with System-F types and
 * coercions. *)

(** For convenience, and to follow what the constraint generator does more
 * closely, we use a functor for the first type. *)

open Algebra.Identifiers

module Make (S: Algebra.SOLVER): sig

  type expression = [
    | `Let of (pattern * S.pscheme * expression) list * expression 
    | `Instance of ident * S.instance
    | `App of expression * expression list
    | `Lambda of (pattern * expression) list
    | `Match of expression * (pattern * expression) list
    | `Tuple of expression list
    | `Const of const
  ]
  and pattern = [
    | `Var of ident * S.scheme
    | `Tuple of pattern list
    | `Or of pattern * pattern
    | `Any
  ]
  and const = [
    | `Char of char
    | `Int of int
    | `Float of string
    | `String of string
    | `Unit
  ]

end

type type_var = { index: int; }
type f_type_var = type_var Algebra.Core.type_var
type f_type_term = [
    f_type_var
  | `Cons of Algebra.TypeCons.type_cons * f_type_term list
]
type f_instance = type_var list

type f_expression = [
  | `Let of (f_pattern * f_coercion * int * f_expression) list * f_expression 
  | `Instance of ident * f_instance
  | `App of f_expression * f_expression list (** Maybe we can simplify this later on (do we really want it?) *)
  | `Lambda of (f_pattern * f_expression) list (** This will be converted later on to a simple form that uses `Match. *)
  | `Match of f_expression * (f_pattern * f_expression) list
  | `Tuple of f_expression list
  | `Const of f_const
]
and f_pattern = [
  | `Var of ident * f_type_term option
  | `Tuple of f_pattern list
  | `Or of f_pattern * f_pattern
  | `Any
]
and f_const = [
  | `Char of char
  | `Int of int
  | `Float of string (** This will have to be converted too *)
  | `String of string
  | `Unit (** This will eventually be removed when we have data types *)
]
and f_coercion = [
  | `ForallInTuple of f_coercion
  | `TupleCovariant of f_coercion list
  | `ForallElim of f_coercion * f_type_term
  | `ForallIntro of f_coercion
  | `Identity
]
