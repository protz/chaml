\documentclass[final]{beamer}

\newcommand{\trucPleinEcran}[1]{{%
  \setbeamertemplate{navigation symbols}{}%
  \setbeamertemplate{background}{}%
  \setbeamertemplate{background canvas}{%
    \hfill%
    #1
    \hfill%
   }%
   \frame[plain]{}%
}}

\newcommand{\figurePleinEcran}[1]{{%
  \setbeamertemplate{navigation symbols}{}%
  \setbeamertemplate{background}{}%
  \setbeamertemplate{background canvas}{%
    \hfill%
    \includegraphics[width=\paperwidth,height=\paperheight,keepaspectratio]{#1}%
    \hfill%
   }%
   \frame[plain]{}%
}}

%\usepackage{pgfpages}
%\pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]

\usepackage{amssymb,amsmath}
\usepackage{xcolor}
\usepackage{wrapfig}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{fit}					% fitting shapes to coordinates
\usetikzlibrary{backgrounds}	% drawing the background after the foreground
%\usepackage[]{graphicx}
%\usepackage[french,noend]{algorithm2e}
\tikzstyle{background}=[rectangle, fill=gray!10, inner sep=0.2cm, rounded corners=5mm]
\tikzstyle{pass}=[shade, shading=axis, rounded rectangle, draw, fill=black!10,
        inner sep=5pt, text width=2cm,
        text badly centered, minimum height=1.2cm,
        font=\bfseries\scriptsize\sffamily]
\tikzstyle{tool}=[rectangle, draw, thick, fill=black!10, inner sep=5pt, text
        width=1.5cm,
        text badly centered, minimum height=.8cm,
        font=\bfseries\scriptsize\sffamily] 

\usepackage{stmaryrd}
\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}
\defaultfontfeatures{Mapping=tex-text}
\setsansfont{Museo Sans}
\setromanfont{Museo}
\setmonofont[Scale=.88]{DejaVu Sans Mono}

\mode<presentation> {
  \usetheme{Singapore}
  \setbeamercovered{transparent}
  \AtBeginSection[]{
    \begin{frame}<beamer| handout>[shrink]
      \frametitle{Plan}
      \tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
      %\tableofcontents[sectionstyle=show/show,subsectionstyle=show/show/hide]
    \end{frame}}
  \AtBeginSubsection[]{
    \begin{frame}<beamer| handout>[shrink]
      \frametitle{Plan}
      %\tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
      \tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
    \end{frame}}
}
\setbeamertemplate{navigation symbols}{}

\title{\textsc{Traduction d'OCaml vers une variante de Système F}}
\author{Jonathan Protzenko\\sous la direction de François Pottier}
\date{\today}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Introduction}

\subsection{Aperçu du problème}

\begin{frame}{Pourquoi traduire?}
  \begin{columns}
    \column{.5\columnwidth}
      \begin{itemize}
        \item On veut augmenter la confiance dans la chaîne de compilation
        \item ``Well-typed programs can't go wrong'' (Milner)
        \item Le système de types d'OCaml est trop complexe
      \end{itemize}
    \column{.5\columnwidth}
      \includegraphics[width=\columnwidth]{ocaml.pdf}
  \end{columns}
  \begin{itemize}
    \item Traduire le programme dans un langage de base
    \item Vérifier le typage \emph{a posteriori}
  \end{itemize}
\end{frame}

\begin{frame}{Objectifs à long terme}
  \begin{itemize}
    \item Fournir un langage intermédiaire pour \emph{effectuer des analyses} et
      compiler plus en avant: expressions \emph{simples}, informations de type
      \emph{riches}.
    \item Augmenter la confiance dans la chaîne de compilation: à défaut de
      prouver la correction du typeur, prouver la cohérence de ses résultats.
    \item Clarifier la sémantique du langage original: quelles sont les
      constructions qui s'expriment bien dans FE+?
  \end{itemize}
\end{frame}

\begin{frame}{Dans les grandes lignes…}
  \begin{center}
    \begin{tikzpicture}
      [node distance = 1cm, auto, every node/.style={node distance=3cm}]
      % Place nodes
      \node [pass] (solve) {Résolution de contraintes};
      \node [left of=solve, node distance=3.5cm] (phantom) {};
      \node [pass, above of=phantom, node distance=1cm] (gen) {Génération de contraintes};
      \node [pass, dashed, below of=phantom, node distance=1cm] (gen2) {Autre langage de surface};
      \node [pass, right of=solve, node distance=3.5cm] (camlx) {AST annoté (CamlX)};
      \node [pass, below of=camlx] (fe) {Langage Core (Système FE+)};
      \node [tool, left of=fe] (typecheck) {Type-checking};
      %\node [block, below of=solve] (unify) {Moteur d'unification};
      % Draw edges
      \draw [->, thick] (gen) -- (solve);
      \draw [->, thick, dashed] (gen2) -- (solve);
      \draw [->, thick] (solve) -- (camlx);
      \draw [->, thick] (camlx) -- (fe);
      \draw [->, thick] (typecheck) -- (fe);
      %\path [line, <->] (unify) -- (solve);
      \begin{pgfonlayer}{background}
        \node [background, fit=(gen) (gen2) (solve), pin=-100:Inférence] {};
        \node [background, fit=(camlx) (fe), pin=80:Traduction] {};
      \end{pgfonlayer}

    \end{tikzpicture}
  \end{center}
  \footnotesize Le processus se découpe en deux parties~: génération/résolution de
  contraintes, et traductions jusqu'à Système FE+.
\end{frame}

\subsection{Contributions}

\begin{frame}{Trois grands axes de travail}
  \begin{columns}
    \column{.5\columnwidth}
      \begin{itemize}
        \item Récrire un système d'inférence par contraintes, et l'adapter pour
          donner un \emph{AST annoté}.
        \item Élaborer un processus de traduction d'un fragment d'OCaml vers un
          langage minimaliste
        \item Concevoir le système de types qui permet de justifier le comportement
          d'OCaml
      \end{itemize}
    \column{.5\columnwidth}
      \includegraphics[width=\columnwidth]{screen1.png}
  \end{columns}
\end{frame}

\section{Décoration d'ASTs}

\subsection{Le cœur du problème}

\begin{frame}{L'inférence par contraintes}
  \begin{itemize}
    \item Nouvelle présentation d'un algorithme <<~classique~>>
    \item Séparation claire et élégante entre génération et résolution
    \item Préférable à l'implémentation OCaml, performante mais difficile
      d'accès
  \end{itemize}
  Exemple: $$
  \llbracket \lambda z.t : T \rrbracket \quad = \quad
  \exists X_1 X_2.\left(\text{let }z: X_1 \text{ in } \llbracket t: X_2
  \rrbracket \wedge X_1 \to X_2 \leq T\right)
  $$
\end{frame}

\begin{frame}[fragile]{Que fait l'inférence par contraintes?}
  L'inférence par contraintes répond \underline{oui ou non}.

  Au mieux, affiche les types inférés des \underline{\smash{définitions
  top-level}}.
  \begin{verbatim}
let (x, y) = (fun x -> x) (1, fun x -> x)

val x: int
val y: ∀ α. α → α
  \end{verbatim}

  Comment l'adapter pour afficher un AST annoté?

  \begin{flushright}
    \footnotesize(Pas de value restriction dans les exemples)
  \end{flushright}
\end{frame}

\subsection{Garder les annotations à portée de main}

\tikzstyle{lang}=[rounded rectangle, draw,
        inner sep=5pt,
        text badly centered]

\newcommand{\redsigma}{\ensuremath{\textcolor[HTML]{a40000}{\boldsymbol\sigma}}}

\begin{frame}{Une méthode ad-hoc}
  \begin{center}
    \footnotesize
    \begin{tikzpicture}
      \node [lang, pin=80:OCaml] (caml) {\texttt{let x = fun x -> x in …}};
      \node [below of=caml, node distance=2.5cm] (phantom) {};
      \node [lang, left of=phantom, node distance=3cm, pin=120:Contrainte] (constraint)
        {$\text{let } z: \underbrace{\forall X.\big[ \llbracket t_1 : X
        \rrbracket \big]. X}_{\redsigma}
        \text{ in } \llbracket t_2 : T\rrbracket$};
      \node [lang, right of=phantom, node distance=3cm, pin=80:CamlX <<~à
      trous~>>] (camlx) {\texttt{let x: $\redsigma$ = fun x -> x
        in …}};

      \draw [->, thick] (caml) -- node [text width=2.5cm, below=.2cm, right=.2cm] {Générateur de contraintes} (constraint);
      \draw [->, thick] (caml) -- (camlx);
    \end{tikzpicture}
  \end{center}
  Idée: le générateur de contraintes renvoie \emph{deux} arbres qui
  \emph{partagent} des structures $\sigma$ décrivant les schémas de type.
\end{frame}

\begin{frame}{Fonctionnement de cette méthode}
  \begin{itemize}
    \item Le générateur de contraintes \emph{pré-alloue} des <<~boîtes vides~>>
      correspondant aux futurs résultats du solveur de contraintes.
    \item Le solveur résout la contrainte, et remplit au passage les boîtes.
    \item Les boîtes sont \underline{\smash{partagées}}: après la résolution des
      contraintes, les trous sont remplies, et l'AST <<~CamlX~>> est désormais annoté.
  \end{itemize}
\end{frame}

\begin{frame}{Avec un peu de recul…}
  \begin{itemize}
    \item Simple et efficace~: il s'agit de <<~faire suivre~>> les informations
      nécessaires.
    \item Facile à implémenter~: solution d'une remarquable flexibilité.
    \item Peu élégant~: le contenu des boîtes expose les structures internes du
      solveur.
    \item Pas de scope: les schémas de type sont extrudés, sortis de leur
      contexte.
    \item Formalisation difficile.
  \end{itemize}
  Il faudrait arriver à une forme plus propre et plus propice aux
  transformations…
\end{frame}

\section{Traduction(s)}

\subsection{Quelles traductions~?}

\begin{frame}[fragile]{De CamlX <<~à trous~>>…}

  … vers CamlX <<~tout court~>>

  \begin{itemize}
    \item Se passer des champs mutables et des classes d'équivalence
    \item Types en indices de De Bruijn
    \item Ne pas changer les expressions, simplement les types
  \end{itemize}

  \begin{verbatim}
let (x, y): Λ. [int * (0 → 0)] =
  (fun (x: int * (0 → 0)) -> x)
  (1, (fun (x: 0) -> x))
in
()
  \end{verbatim}
\end{frame}

\begin{frame}[fragile]{Désucrer CamlX vers…}

… Système FE+

  \begin{itemize}
    \item Enlever les constructions redondantes d'OCaml
    \item Offrir de meilleures garanties (unicité des identifiants)
    \item Une vraie syntaxe des expressions Système F
    \item Et des coercions (\emph{more on this later})
  \end{itemize}

  \begin{verbatim}
match
  Λ. (λ (x/41: int * (0 → 0)) -> x/41)
     (1, (λ (x/42: 0) -> x/42))
with
  | (x/39, y/40) ▸ ∀×; ×0[•[bottom]] ->
      ()
  \end{verbatim}

\end{frame}

\subsection{Le décodeur}

\begin{frame}{Remplissage des boîtes…}
  Sont conservées les \underline{\smash{schémas de types}} et les
  \underline{\smash{variables d'instanciation}}.

  \begin{center}
    \fbox{Les schémas sont résolus au niveau des contraintes \texttt{let}.}
  \end{center}

  \texttt{function, fun, let, match} $\to$ contrainte \texttt{let}. Donc :
  \begin{itemize}
    \item créer une boîte ;
    \item l'attacher à la contrainte \texttt{let} ;
    \item l'attacher au nœud CamlX correspondant.
  \end{itemize}
\end{frame}

\begin{frame}{… et nettoyage}
 les structures union-find sont mutables et contiennent du partage. On utilise
 des types avec des indices de De Bruijn.

 \begin{itemize}
   \item La généralisation se fait au niveau des \texttt{let}~: pas de nœud
     $\Lambda$ dans la syntaxe des expressions ;
   \item L'application de type se fait au niveau des instanciations~: pas de
     nœud <<~application de type~>> ;
   \item les patterns sont présents dans les \texttt{let} et \texttt{function} ;
   \item les \texttt{let} sont multiples.
 \end{itemize}

 C'est une représentation avec des types clairs mais des expressions complexes.
\end{frame}

\subsection{Le désucreur}

\begin{frame}{Rôle du désucreur}
  \begin{itemize}
    \item Les patterns sont utilisés à de nombreux endroits en OCaml: on les
      restreint aux \texttt{match} uniquement.
    \item Les \texttt{let and} peuvent définir simultanément plusieurs motifs:
      on utilise des identifiants uniques pour s'en passer.
    \item Les $\Lambda$ et les applications de types deviennent des nœuds
      normaux de la syntaxe des expressions.
  \end{itemize}
  … et surtout, sont ajoutées des \underline{coercions}.
\end{frame}

\section{Système F plus coercions}

\begin{frame}{<++>}
<++>
\end{frame}

\begin{frame}{<++>}
<++>
\end{frame}

\begin{frame}{<++>}
<++>
\end{frame}

\begin{frame}{<++>}
<++>
\end{frame}

\begin{frame}{<++>}
<++>
\end{frame}

\begin{frame}{<++>}
<++>
\end{frame}

\begin{frame}{<++>}
<++>
\end{frame}

\end{document}
